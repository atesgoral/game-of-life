<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r73/three.min.js"></script>
<style>
body {
    -webkit-user-select: none;  /* Chrome all / Safari all */
    -moz-user-select: none;     /* Firefox all */
    -ms-user-select: none;      /* IE 10+ */
    user-select: none;          /* Likely future */          
    position: relative;
    margin: 0;
    padding: 0;
    background: #000;
    overflow: hidden;  
}
.controls {
    position: absolute;
    top: 0;
    left: 0;
    padding: 10px;
}
</style>
</head>
<body>
    <div class="controls">
        <button id="load">Load</button>
        <button id="save">Save</button>
        <button id="clear">Clear</button>
        <button id="spawn">Spawn</button>
        <button id="pause">Pause</button>
        <button id="grid">Grid On</button>
    </div>

<script>
var camera, scene, renderer;
var group;

var cubes = [];

init();
animate();

function init() {

    camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
    camera.position.z = 400;

    scene = new THREE.Scene();

    var ambientLight = new THREE.AmbientLight(0x000000);
    scene.add( ambientLight );

    var lights = [];
    lights[0] = new THREE.PointLight( 0xffffff, 1, 0 );
    lights[1] = new THREE.PointLight( 0xffffff, 1, 0 );
    lights[2] = new THREE.PointLight( 0xffffff, 1, 0 );
    
    lights[0].position.set(0, 1000, 0);
    lights[1].position.set(500, 1000, 500);
    lights[2].position.set(-500, -1000, -500);

    scene.add( lights[0] );
    scene.add( lights[1] );
    scene.add( lights[2] );
    
    var geometry = new THREE.BoxGeometry(10, 10, 10);
    var material = new THREE.MeshLambertMaterial({ color: 0x0000ff });

    group = new THREE.Group();

    for (var i = 0; i < 50; i++) {
        for (var j = 0; j < 50; j++) {
            var mesh = new THREE.Mesh(geometry, material);

            mesh.translateX((i - 25) * 10);
            mesh.translateY((j - 25) * 10);

            mesh.visible = false;

            group.add(mesh);

            cubes[j * 50 + i] = mesh;
        }
    }

    group.add(mesh);

    scene.add( group );

    renderer = new THREE.WebGLRenderer();
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    //

    window.addEventListener( 'resize', onWindowResize, false );

}

function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

}

function animate() {

    requestAnimationFrame( animate );

    group.rotation.x += 0.005;
    group.rotation.y += 0.01;

    renderer.render( scene, camera );
}


var pause = document.getElementById('pause');

var grid = document.getElementById('grid');

document.getElementById('load').addEventListener('click', function () {
  	if (localStorage.getItem('matrix')) {
    	matrix = JSON.parse(localStorage.getItem('matrix'));
    }
});

document.getElementById('save').addEventListener('click', function () {
    localStorage.setItem('matrix', JSON.stringify(matrix));
});

document.getElementById('clear').addEventListener('click', function () {
    matrix = [];
});

document.getElementById('spawn').addEventListener('click', function () {
    spawnCells(100);
});

var isPaused = false;

var isGridEnabled = false;

var isSpawning;

pause.addEventListener('click', function () {
    isPaused = !isPaused;
    
    pause.innerHTML = isPaused ? 'Resume' : 'Pause';    
});

grid.addEventListener('click', function () {
    isGridEnabled = !isGridEnabled;
    
    grid.innerHTML = isGridEnabled ? 'Grid Off' : 'Grid On';    
});

var isMouseDown = false;

// canvas.addEventListener('mousedown', function (evt) {
//     var col = Math.floor(evt.offsetX / 10);
//     var row = Math.floor(evt.offsetY / 10);
//     var idx = row * 50 + col;
    
//     isSpawning = !matrix[idx];
    
//     matrix[idx] = isSpawning;
    
//     isMouseDown = true;
// });

// canvas.addEventListener('mouseup', function (evt) {
//     isMouseDown = false;
// });

// canvas.addEventListener('mousemove', function (evt) {
//     if (isMouseDown) {        
//         var col = Math.floor(evt.offsetX / 10);
//         var row = Math.floor(evt.offsetY / 10);
//         var idx = row * 50 + col;

//         if (col >= 0 && col < 50 && row >= 0 && row < 50) {
//             matrix[idx] = isSpawning;
//         }
//     }
// });

function drawMatrix() {
    var idx = 0;
    
    for (var row = 0; row < 50; row++) {
        for (var col = 0; col < 50; col++) {
            cubes[idx].visible = !!matrix[idx];
            // if (matrix[idx]) {
            //     context.fillStyle = 'blue';
            //     context.fillRect(col * 10, row * 10, 10, 10);
            // }
            
            // if (isGridEnabled) {
            //     context.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            //     context.strokeRect(col * 10, row * 10, 10, 10);
            // }
            
            idx++;
        }
    }
}

var neighOffsets = [
    { x: 0, y: -1 },
    { x: 1, y: -1 },
    { x: 1, y: 0 },
    { x: 1, y: 1 },
    { x: 0, y: 1 },
    { x: -1, y: 1 },
    { x: -1, y: 0 },
    { x: -1, y: -1 }
];

function progressMatrix() {
    var idx = 0;
    
    var newMatrix = [];
        
    for (var row = 0; row < 50; row++) {
        for (var col = 0; col < 50; col++) {
            var neighCount = 0;
            
            newMatrix[idx] = matrix[idx];
            
            for (var neigh = 0; neigh < 8; neigh++) {
                var neighX = (col + neighOffsets[neigh].x + 50) % 50;
                var neighY = (row + neighOffsets[neigh].y + 50) % 50;
                
                if (matrix[neighY * 50 + neighX]) {
                    neighCount++;
                }
            }           
                       
            if (matrix[idx]) {
                if (neighCount < 2) {
                    newMatrix[idx] = false;
                } else if (neighCount > 3) {
                    newMatrix[idx] = false;
                }
            } else {
                if (neighCount === 3) {
                    newMatrix[idx] = true;
                }
            }
        
        	idx++;
        }
    }
    
    matrix = newMatrix;
}

var matrix = [];

function spawnCells(howMany) {
    for (var i = 0; i < howMany; i++) {
        matrix[Math.floor(Math.random() * 50 * 50)] = true;
    }
}

function drawFrame() {
    drawMatrix();

    if (!isPaused) {
		progressMatrix();
    }
 
    setTimeout(drawFrame, 60);
}

spawnCells(100);
drawFrame();
</script>
</body>
</html>